File "lib/ast/dune", line 21, characters 14-28:
21 |   (preprocess (pps ppx_jane))
                   ^^^^^^^^^^^^^^
Warning: .merlin generated is inaccurate. Cannot mix preprocessed and non
preprocessed specificiations.
Split the stanzas into different directories or silence this warning by
adding (allow_approximate_merlin) to your dune-project.
no_separate_original_formula_in_exists
pvar key
X0
show_typ
SInt;SInt
gen name: y, id: 0
gen name: x, id: 1
gen name: X0, id: 2
pvar key
X1
show_typ
SInt;SInt
gen name: y, id: 3
gen name: x, id: 4
gen name: X1, id: 5
pvar key
Y0
show_typ
SInt;SInt
gen name: y, id: 6
gen name: x, id: 7
gen name: Y0, id: 8
pvar key
Y1
show_typ
SInt;SInt
gen name: y, id: 9
gen name: x, id: 10
gen name: Y1, id: 11
gen name: Sentry, id: 12
key
x
gen name: x, id: 13
key
y
gen name: y, id: 14
key
x
gen name: x, id: 15
key
y
gen name: y, id: 16
key
x
gen name: x, id: 17
key
y
gen name: y, id: 18
key
x
gen name: x, id: 19
key
y
gen name: y, id: 20
[Main:App:hes Input]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx13:int.λy14:int.x13 + y14 >= 0 && Y1 (x13 - 1) y14
  X1 : int -> int -> bool =ν λx15:int.λy16:int.x15 + y16 >= 0 && Y0 x15 (y16 + 1)
  Y0 : int -> int -> bool =ν λx17:int.λy18:int.X1 (x17 - 1) y18
  Y1 : int -> int -> bool =ν λx19:int.λy20:int.X0 x19 (y20 + 1)
[Main:App:Simplified]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx13:int.λy14:int.x13 + y14 >= 0 && Y1 (x13 - 1) y14
  X1 : int -> int -> bool =ν λx15:int.λy16:int.x15 + y16 >= 0 && Y0 x15 (y16 + 1)
  Y0 : int -> int -> bool =ν λx17:int.λy18:int.X1 (x17 - 1) y18
  Y1 : int -> int -> bool =ν λx19:int.λy20:int.X0 x19 (y20 + 1)
[Solver:App:Decompose lambdas]
  Sentry : bool =ν (X0 :int -> int -> bool) 0 0
  X0 : int -> int -> bool =ν
    λx13:int.λy14:int.x13 + y14 >= 0 && (Y1 :int -> int -> bool) (x13 - 1) y14
  X1 : int -> int -> bool =ν
    λx15:int.λy16:int.x15 + y16 >= 0 && (Y0 :int -> int -> bool) x15 (y16 + 1)
  Y0 : int -> int -> bool =ν λx17:int.λy18:int.(X1 :int -> int -> bool) (x17 - 1) y18
  Y1 : int -> int -> bool =ν λx19:int.λy20:int.(X0 :int -> int -> bool) x19 (y20 + 1)
get_recurring_predicates
X0, X1, Y0, Y1, 
converted and simplified
/tmp/nuonly-262887997.smt2
Run command (muapprox) "/opt/home2/git/hflmc2_mora/_build/default/bin/main.exe /tmp/nuonly-239096995.smt2"
[Main:App:Input]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx135:int.λy146:int.x135 + y146 >= 0 && Y1 (x135 - 1) y146
  X1 : int -> int -> bool =ν λx157:int.λy168:int.x157 + y168 >= 0 && Y0 x157 (y168 + 1)
  Y0 : int -> int -> bool =ν λx179:int.λy1810:int.X1 (x179 - 1) y1810
  Y1 : int -> int -> bool =ν λx1911:int.λy2012:int.X0 x1911 (y2012 + 1)
[Main:App:Simplified]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx135:int.λy146:int.x135 + y146 >= 0 && Y1 (x135 - 1) y146
  X1 : int -> int -> bool =ν λx157:int.λy168:int.x157 + y168 >= 0 && Y0 x157 (y168 + 1)
  Y0 : int -> int -> bool =ν λx179:int.λy1810:int.X1 (x179 - 1) y1810
  Y1 : int -> int -> bool =ν λx1911:int.λy2012:int.X0 x1911 (y2012 + 1)
Sentry *[X21()]
X0 (int(x1315) -> (int(y1416) -> *[X15(y1416,x1315)]))
X1 (int(x1519) -> (int(y1620) -> *[X9(y1620,x1519)]))
Y0 (int(x1723) -> (int(y1824) -> *[X5(y1824,x1723)]))
Y1 (int(x1927) -> (int(y2028) -> *[X1(y2028,x1927)]))


infering new formula: Sentry = ((X0 0) 0)
[Result]
X21() => X15(0,0)
tt => X21()


infering new formula: X0 = (\int(x135).(\int(y146).(x135 + y146>=0:X16(y146,x135) && ((Y1 x135 - 1) y146):X17(y146,x135))))
[Result]
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: X1 = (\int(x157).(\int(y168).(x157 + y168>=0:X10(y168,x157) && ((Y0 x157) y168 + 1):X11(y168,x157))))
[Result]
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: Y0 = (\int(x179).(\int(y1810).((X1 x179 - 1) y1810)))
[Result]
X5(x36,x35) => X9(x36,x35 - 1)
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: Y1 = (\int(x1911).(\int(y2012).((X0 x1911) y2012 + 1)))
[Result]
X1(x38,x37) => X15(x38 + 1,x37)
X5(x36,x35) => X9(x36,x35 - 1)
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()
[Size] 1
Run command: "hoice /tmp/hoice-150316853.smt2"
sat
(model
  (define-fun X9
    ( (v_0 Int) (v_1 Int) ) Bool
    false
  )
  (define-fun X21
    ( ) Bool
    true
  )
  (define-fun X15
    ( (v_0 Int) (v_1 Int) ) Bool
    (>= (+ v_0 v_1) 0)
  )
  (define-fun X1
    ( (v_0 Int) (v_1 Int) ) Bool
    (X15 v_0 (+ 1 v_1))
  )
  (define-fun X5
    ( (v_0 Int) (v_1 Int) ) Bool
    (X9 (+ v_0 (- 1)) v_1)
  )
)
Process result:
out: sat
(model
  (define-fun X9
    ( (v_0 Int) (v_1 Int) ) Bool
    false
  )
  (define-fun X21
    ( ) Bool
    true
  )
  (define-fun X15
    ( (v_0 Int) (v_1 Int) ) Bool
    (>= (+ v_0 v_1) 0)
  )
  (define-fun X1
    ( (v_0 Int) (v_1 Int) ) Bool
    (X15 v_0 (+ 1 v_1))
  )
  (define-fun X5
    ( (v_0 Int) (v_1 Int) ) Bool
    (X9 (+ v_0 (- 1)) v_1)
  )
)
status: Ok
err:


Profiling:
  CHC Solver: 0.048862 sec
did not calculate refinement. Use --show-refinement
Verification Result:
  Valid
Profiling:
  total: 0.051665 sec
Process result:
out: [Main:App:Input]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx135:int.λy146:int.x135 + y146 >= 0 && Y1 (x135 - 1) y146
  X1 : int -> int -> bool =ν λx157:int.λy168:int.x157 + y168 >= 0 && Y0 x157 (y168 + 1)
  Y0 : int -> int -> bool =ν λx179:int.λy1810:int.X1 (x179 - 1) y1810
  Y1 : int -> int -> bool =ν λx1911:int.λy2012:int.X0 x1911 (y2012 + 1)
[Main:App:Simplified]
  Sentry : bool =ν X0 0 0
  X0 : int -> int -> bool =ν λx135:int.λy146:int.x135 + y146 >= 0 && Y1 (x135 - 1) y146
  X1 : int -> int -> bool =ν λx157:int.λy168:int.x157 + y168 >= 0 && Y0 x157 (y168 + 1)
  Y0 : int -> int -> bool =ν λx179:int.λy1810:int.X1 (x179 - 1) y1810
  Y1 : int -> int -> bool =ν λx1911:int.λy2012:int.X0 x1911 (y2012 + 1)
Sentry *[X21()]
X0 (int(x1315) -> (int(y1416) -> *[X15(y1416,x1315)]))
X1 (int(x1519) -> (int(y1620) -> *[X9(y1620,x1519)]))
Y0 (int(x1723) -> (int(y1824) -> *[X5(y1824,x1723)]))
Y1 (int(x1927) -> (int(y2028) -> *[X1(y2028,x1927)]))


infering new formula: Sentry = ((X0 0) 0)
[Result]
X21() => X15(0,0)
tt => X21()


infering new formula: X0 = (\int(x135).(\int(y146).(x135 + y146>=0:X16(y146,x135) && ((Y1 x135 - 1) y146):X17(y146,x135))))
[Result]
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: X1 = (\int(x157).(\int(y168).(x157 + y168>=0:X10(y168,x157) && ((Y0 x157) y168 + 1):X11(y168,x157))))
[Result]
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: Y0 = (\int(x179).(\int(y1810).((X1 x179 - 1) y1810)))
[Result]
X5(x36,x35) => X9(x36,x35 - 1)
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()


infering new formula: Y1 = (\int(x1911).(\int(y2012).((X0 x1911) y2012 + 1)))
[Result]
X1(x38,x37) => X15(x38 + 1,x37)
X5(x36,x35) => X9(x36,x35 - 1)
X9(x34,x33) => (x33 + x34>=0 /\ X5(x34 + 1,x33))
X15(x32,x31) => (x31 + x32>=0 /\ X1(x32,x31 - 1))
X21() => X15(0,0)
tt => X21()
[Size] 1
Run command: "hoice /tmp/hoice-150316853.smt2"
sat
(model
  (define-fun X9
    ( (v_0 Int) (v_1 Int) ) Bool
    false
  )
  (define-fun X21
    ( ) Bool
    true
  )
  (define-fun X15
    ( (v_0 Int) (v_1 Int) ) Bool
    (>= (+ v_0 v_1) 0)
  )
  (define-fun X1
    ( (v_0 Int) (v_1 Int) ) Bool
    (X15 v_0 (+ 1 v_1))
  )
  (define-fun X5
    ( (v_0 Int) (v_1 Int) ) Bool
    (X9 (+ v_0 (- 1)) v_1)
  )
)
Process result:
out: sat
(model
  (define-fun X9
    ( (v_0 Int) (v_1 Int) ) Bool
    false
  )
  (define-fun X21
    ( ) Bool
    true
  )
  (define-fun X15
    ( (v_0 Int) (v_1 Int) ) Bool
    (>= (+ v_0 v_1) 0)
  )
  (define-fun X1
    ( (v_0 Int) (v_1 Int) ) Bool
    (X15 v_0 (+ 1 v_1))
  )
  (define-fun X5
    ( (v_0 Int) (v_1 Int) ) Bool
    (X9 (+ v_0 (- 1)) v_1)
  )
)
status: Ok
err:


Profiling:
  CHC Solver: 0.048862 sec
did not calculate refinement. Use --show-refinement
Verification Result:
  Valid
Profiling:
  total: 0.051665 sec
status: Ok
err:


PARSED STATUS: valid

[[MAIN]] Verification Result:
  valid
Profiling:
  total: 0.116789 sec
