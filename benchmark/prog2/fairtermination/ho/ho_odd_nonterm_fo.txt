/* invalid */
%PROGRAM

let f fx k =
  event called;
  check fx (\b.
    if b = 1 then
      k
    else (
      if <d> * then
        (event a; f fx k)
      else
        (event b; pred2 fx (\x. f x k))
    )
  )

let check x k =
    if x = 0 then k 1 else k 0

let pred2 x k =
    k (x - 2)

/* xxの呼び出しの無限列がfairであると判定されると、常にfair-infinite traceがあるという結果になる. そのためinfairと判定される必要がある */
let xx fx k =
  event called;
  event a;
  if <d> * then
    f fx k
  else
    xx fx k

let () =
  let r = <_exists> * in
  if r > 0 then
    xx r (\. ())
  else
    ()

/* there exists fair-infinite trace <=> the reduced formula is valid */
%TRANSITION
q_0 called -> (1, q_0).
q_a called -> (1, q_0).
q_b called -> (1, q_0).

q_0 d -> (1, q_0) \/ (2, q_0).
q_a d -> (1, q_0) \/ (2, q_0).
q_b d -> (1, q_0) \/ (2, q_0).

q_0 a -> (1, q_a).
q_a a -> (1, q_a).
q_b a -> (1, q_a).

q_0 b -> (1, q_b).
q_a b -> (1, q_b).
q_b b -> (1, q_b).

q_0 nullary -> false.
q_a nullary -> false.
q_b nullary -> false.

%PRIORITY
/* {(a, b)} */
q_0 -> 0.
q_a -> 1.
q_b -> 2.
