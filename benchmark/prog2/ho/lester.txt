/* Taken from
   Lester, Neatherway, Ong, and Ramsay,
   "Model Checking Liveness Properties of Higher-Order Functional Programs",
   Appendix H.1
 */
/* valid */
%PROGRAM
let loop fi y fn k =
  fi (\i.
    fn (\n.
      if i < n then (
        event write;
        loop (\k2. k2 (i + 1)) y fn k
      ) else y k
    )
  )

let g y n k = loop (\k. k 0) y n k
  
let f x y fn k =
  if <d> * then (
    event read;
    fn (\n.
      f x y (\k2. k2 (n+1)) k
    )
  ) else (
    x (\. g y fn k)
  )

let xx x y n k =
  event inf_called;
  if <d> * then
    f x y n k
  else
    xx x y n k

let () =
  let s = (\k. event close_in; k) in
  let t = (\k. event close_out; k) in
  xx s t (\k. k 0) (\. ())

/* AG (close_in => AF close_out) */
/* branchはdemonic */
/* q0 close_in -> で、この時点よりも後でclose_outされることをチェックするスレッドqfと、この時点より後のclose_inを見ていくq0とに分岐 */
/* ひとたびqfになった後、close_outがやがて呼ばれないければinvalidにしたいので、qfで停止した場合=nullaryはfalse. qfが無限に繰り返す場合はodd priority */
%TRANSITION
q0 d -> (1, q0) /\ (2, q0).
q0 close_in -> (1, qf) /\ (1, q0).
q0 close_out -> (1, q0).
q0 read -> (1, q0).
q0 write -> (1, q0).
q0 nullary -> true.
q0 inf_called -> (1, q_ic).

qf d -> (1, qf) /\ (2, qf).
qf close_in -> (1, qf).
qf close_out -> true.
qf read -> (1, qf).
qf write -> (1, qf).
qf nullary -> false.
qf inf_called -> (1, q_ic).

q_ic d -> (1, q0) /\ (2, q0).
q_ic close_in -> (1, qf) /\ (1, q0).
q_ic close_out -> (1, q0).
q_ic read -> (1, q0).
q_ic write -> (1, q0).
q_ic nullary -> true.
q_ic inf_called -> (1, q_ic).

%PRIORITY
q_ic -> 0.
q0 -> 0.
qf -> 1.

/*
/* lester prover --coe=1,1 --coe-arg=1,1 */
/* timeout (with hoice or z3) */
/* should be valid */
%HES
Sentry =v
  ∀s. 
   s < 1
   \/ Xx__q 0 s (\k__q. \k__qf. k__qf /\ k__q) (\k__q. k__q) true (\k__q. k__q 0)
       (\k__qf. k__qf 0) true.

Loop__qf recLoop__qf _i _n fi__qf y__qf y__qf2 fn__qf fn__qf2 =v
  recLoop__qf > 0
  /\ fi__qf (Loop94__qf recLoop__qf _n fn__qf fn__qf2 y__qf y__qf2).

Loop949596__qf i k2__qf =v k2__qf (i + 1).

F99100__qf n k2__qf =v k2__qf (n + 1).

F98__qf _n t y__qf y__qf2 fn__qf fn__qf2 =v
  ∀recLoop__qf. 
   recLoop__qf < 1 + 1 * t \/ recLoop__qf < 1 + (-1) * t
   \/ recLoop__qf < 1 + 1 * 0
   \/ recLoop__qf < 1 + (-1) * 0
   \/ recLoop__qf < 1
   \/ Loop94__qf recLoop__qf _n fn__qf fn__qf2 y__qf y__qf2 0.

Loop__q _i _n fi__q y__q fn__q k__q =v
  fi__q
   (\i. 
     fn__q
      (\n. 
        (i >= n \/ Loop__q (_i + 1) _n (\k2__q. k2__q (i + 1)) y__q fn__q k__q)
        /\ (i < n \/ y__q k__q))).

Loop94__qf recLoop__qf _n fn__qf fn__qf2 y__qf y__qf2 i =v
  fn__qf
   (\n. 
     (i >= n
      \/ Loop__qf (recLoop__qf - 1) (i + 1) _n (Loop949596__qf i) y__qf2 y__qf2 fn__qf2
          fn__qf2)
     /\ (i < n \/ y__qf)).

G__q _n y__q n__q k__q =v Loop__q 0 _n (\k__q2. k__q2 0) y__q n__q k__q.

F__q _n t x__q y__q y__qf fn__q fn__qf k__q =v
  fn__q
   (\n. 
     ∀s. 
      s < 1 * n + 1 \/ s < (-1) * n + 1 \/ s < 1
      \/ F__q (_n + 1) s x__q y__q y__qf (\k2__q. k2__q (n + 1)) (F99100__qf n) k__q)
  /\ (∀s. 
       s < 1 * t + 1 \/ s < (-1) * t + 1 \/ s < 1
       \/ x__q (G__q _n y__q fn__q k__q) (F98__qf _n s y__qf y__qf fn__qf fn__qf)).

Xx__q _n t x__q y__q y__qf n__q n__qf k__q =v
  (∀s. 
    s < 1 * t + 1 \/ s < (-1) * t + 1 \/ s < 1
    \/ F__q _n s x__q y__q y__qf n__q n__qf k__q)
  /\ (∀s. 
       s < 1 * t + 1 \/ s < (-1) * t + 1 \/ s < 1
       \/ Xx__q _n s x__q y__q y__qf n__q n__qf k__q).
*/
