/* invalid */
%PROGRAM
let halt =
  event called;
  event halt;
  halt
  
let bar x k =
  event called;
  /* event bar; */
  if x>0 then bar (x-1) k
  else k x

let foo x =
  event called;
  /* event foo; */
  if x<=0 then foo x
  else halt

let () =
  if <d> * then foo 0
  else bar (<_exists> *) (\r.
    foo r
  )

%TRANSITION
q_0 called -> (1, q_0).
q_halt called -> (1, q_0).
q_bot called -> (1, q_bot).

q_0 d -> ((1, q_0) /\ (2, q_bot)) \/ ((1, q_bot) /\ (2, q_0)).
q_halt d -> ((1, q_0) /\ (2, q_bot)) \/ ((1, q_bot) /\ (2, q_0)).
q_bot d -> (1, q_bot) /\ (2, q_bot).

q_0 halt -> (1, q_halt).
q_halt halt -> (1, q_halt).
q_bot halt -> (1, q_bot).

/* when program contains unit value, we can express a condition "{(called, _)}" by adding "q nullary -> true." rules for all states q
  because by adding the rules, finite "called" trace leads to true */
/* if "{(always, _)}", add "q nullary -> false." */
%PRIORITY
/* {(always, halt)} */
q_halt -> 2.
q_0 -> 1.
q_bot -> 0.
