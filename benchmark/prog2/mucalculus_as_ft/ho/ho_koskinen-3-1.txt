/* nu-HFLZに帰着される */
/* unknown in katsura solver */
%PROGRAM
let halt =
  event called;
  /* event halt; */
  halt
  
let bar fx k =
  event called;
  /* event bar; */
  check fx (\b.
    if b = 1 then bar (pred fx) k
    else k fx
  )

let foo fx =
  event called;
  event foo;
  fx (\x.
    if x<=0 then foo fx
    else halt
  )

let pred fx k =
  fx (\x.
    k (x - 1)
  )

let check fx k =
  event foo;
  if <d> * then
    fx (\x.
      if x > 0 then k 1 else k 0
    )
  else
    check fx k

let xx fx k =
  event foo;
  if <d> * then
    bar fx k
  else
    xx fx k

let () =
  if <d> * then foo (\k. k 0)
  else (
    let x = <_exists> * in
    xx (\k. k x) (\r.
      foo r
    )
  )

%TRANSITION
q_0 called -> (1, q_0).
q_foo called -> (1, q_0).

q_0 d -> (1, q_0) \/ (2, q_0).
q_foo d -> (1, q_0) \/ (2, q_0).

q_0 foo -> (1, q_foo).
q_foo foo -> (1, q_foo).

%PRIORITY
/* {(foo, never)} */
q_foo -> 1.
q_0 -> 0.
