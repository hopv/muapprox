/* invaid (nu-HFLZ) */
%PROGRAM
let halt =
  event called;
  event halt;
  halt
  
let bar fx k =
  event called;
  /* event bar; */
  check fx (\b.
    if b = 1 then pred fx (\r. bar r k)
    else k fx
  )

let foo x =
  event called;
  /* event foo; */
  if x<=0 then foo x
  else halt
    
let pred x k =
  k (x - 1)

let check fx k =
  event called;
  if <d> * then
    if fx > 0 then k 1 else k 0
  else
    check fx k

let xx fx k =
  event called;
  if <d> * then
    bar fx k
  else
    xx fx k

let () =
  if <d> * then foo 0
  else (
    let x = <_exists> * in
    xx x (\r.
      foo r
    )
  )

%TRANSITION
q_0 called -> (1, q_0).
q_halt called -> (1, q_0).

q_0 d -> (1, q_0) \/ (2, q_0).
q_halt d -> (1, q_0) \/ (2, q_0).

q_0 halt -> (1, q_halt).
q_halt halt -> (1, q_halt).

/* when program contains unit value, we can express a condition "{(called, _)}" by adding "q nullary -> true." rules for all states q
  because by adding the rules, finite "called" trace leads to true */
/* if "{(always, _)}", add "q nullary -> false." */
%PRIORITY
/* {(always, halt)} */

q_halt -> 2.
q_0 -> 1.
