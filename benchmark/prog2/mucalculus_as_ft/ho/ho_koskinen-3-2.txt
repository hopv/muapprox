%PROGRAM
let halt =
  event called;
  event halt;
  halt
  
let bar fx k =
  event called;
  /* event bar; */
  check fx (\b.
    if b = 1 then bar (pred fx) k
    else k fx
  )

let foo fx =
  event called;
  /* event foo; */
  fx (\x.
    if x<=0 then foo fx
    else halt
  )

let pred fx k =
  fx (\x.
    k (x - 1)
  )

let check fx k =
  event called;
  if <d> * then
    fx (\x.
      if x > 0 then k 1 else k 0
    )
  else
    check fx k

let xx fx k =
  event called;
  if <d> * then
    bar fx k
  else
    xx fx k

let () =
  if <d> * then foo (\k. k 0)
  else (
    let x = <_exists> * in
    xx (\k. k x) (\r.
      foo r
    )
  )

%TRANSITION
q_0 called -> (1, q_0).
q_halt called -> (1, q_0).

q_0 d -> (1, q_0) \/ (2, q_0).
q_halt d -> (1, q_0) \/ (2, q_0).

q_0 halt -> (1, q_halt).
q_halt halt -> (1, q_halt).

/* when program contains unit value, we can express a condition "{(called, _)}" by adding "q nullary -> true." rules for all states q
  because by adding the rules, finite "called" trace leads to true */
/* if "{(always, _)}", add "q nullary -> false." */
%PRIORITY
/* {(always, halt)} */

q_halt -> 2.
q_0 -> 1.
