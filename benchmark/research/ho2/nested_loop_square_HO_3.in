/* まず、整数値のdata-flowを見る */
/* 結果的に不要な定数項は無くしている */
/* 現実には、+1とかのように、定数項を加えないと解けない場合がある */
/* これをやると結局（boundで）使わない変数は削除できそう */
/*

問題点:
* data-analysisの結果が本当にover-approximationになっているのか？ 大丈夫なはず
  * そもそも、ここで解けるようにすべき式のスコープは？ 定式化は難しそう。arrayの高階関数によるエンコーディングくらいが解ければ理想
* 係数、定数の情報をどこで取得するか？ 結局、テスト実行や式の形を元にするヒューリスティックスしかないか
  * ヒューリスティックスには、高階の式の中で現れる整数関数とか定数を使った式にするくらい
  * 外延的な等価性、記号的実行
*/
%HES
Sentry =u
  ∀n.
    Mult
      /* 定数を渡す. kが渡されているが、意図としてはkは「返り値」なので、値の依存元にはならないはず？ */
      [0] (\i k. k 0)
      /* nを渡す */
      [n] (\i k. k n)
      [n] (\i k. k n)
      /* これはどうなるのか. nは近似回数として使われうる、gに渡される値に依存する. ただし、ここでスコープにある変数はnだけなので、nを渡せばいいはず */
      /* 定数項はどうすればいいか. 基本は無しで、変数に直接定数が加算されている場合はそれを加えるとか */
      [n] (\i g.
        ∀r2. (r2 >= 1 + n /\ r2 >= 1 - n /\ r2 >= 1 + i /\ r2 >= 1 - i) =>
        Main [.] (\r. true) [i] g
      ).

Main [k_i] k [g_i] g =u
  Check [g_i] g [k_i, g_i] (\b.
    (b =  0 => k 0) /\
    (b != 0 => Main [k_i] k [g_i] (Pred [g_i] g))
  ).

Mult [acc_i] acc [f_i] f [g_i] g [k_i] k =u
  Check
    [f_i] f
    /* 依存しうる値はスコープ内のすべて */
    [acc_i, f_i, g_i, k_i] (\b.
      (b = 0 => k [acc_i] acc) /\
      (b = 1 => Mult [acc_i, g_i] (Add [acc_i] acc [g_i] g) [f_i] (Pred [f_i] f) [g_i] g [k_i] k)
    ).

Add [f_i] f [g_i] g [k_i] k =u f [g_i, k_i] (\fx. g [k_i] (\gx. k (fx + gx))).

Pred [f_i] f [k_i] k =u f [k_i] (\r. k (r - 1)).

Check [f_i] f [k_i] k =u f [k_i] (\n. (n <= 0 => k 0) /\ (n > 0 => k 1)).
