
/*

(\[k_i] k. k 0), (\[k_i] k. k n) -> acc, (\[k_i] k. k n) -> g -> g -> acc -> g -> g
g -> Check # Main
f -> Check # Mult

式を解析しないと、「不要」と判定できない
「不要」 ... 以降の簡約列でmuが現れない？これだと大きすぎる。
Mainの引数が全て関わりうるとしたときに、どの変数が必要になるか。
k, g, gが関わりうる。
g <- acc. fは関わっていない？しかし、Multの再帰回数はfで与えられて、fが関わる可能性もあるから一般にはそうは言えない。
中身を静的に見るしか無いか？
「定数回の簡約で済む」という仮定があるので、さらに定数回の値を返すのが定数回の値に限れば静的にpossible expression setがわかるはず

# Pred f を解析
(\[k_i] k. k n) -> f
(Pred f) -> f

// Predの第一引数に来る形
// 再帰的定義のようになる
f \in {(\k. k n), (Pred f)}
k \in {(\r. k (r - 1)), (\n. (n <= 0 => k 0) /\ (n > 0 => k 1))} (Checkの内部) ここで、kには再帰が含まれるので、解析できないと判断

Pred f
(inline展開して、fを適用) = \k'. (\k. k n) (\r. k' (r - 1))
(lambdaの中身を簡約) = \k'. k' (n - 1)

どこで再帰的展開を止める？ => nを単に任意の整数値と抽象化すれば等価性を判定できる（条件分岐があると無理（というか必ずしも等価ではない））

たまたま構文的に同じ形になったからできた。
（型が同一で）簡約が定数回なら、等価性は決定可能？（しかし、引数の変化が"対応する部分"は必ずしもわからない？）
部分適用を「適切な」部分まで展開したから。
実際には、引数が静的に定まるところまで展開する？

Pred [f_i] f [k_i] k に対して
f_iは、もともと使われていないので、不要だとわかる
k_iはfに適用される。Predの第一引数(f)の中身は、常に \k. k m という形なので、k_iも不要だとわかる。ただし、Predの型が一致しなければいけない。うまく制約を伝搬させていく。Checkで使っているが、結局k_iも他で使わない。

fがg, accに流れないというのはどうやってわかる？
明らかに、Add acc g は、（Add, acc, gは、他に依存する値は無いという仮定のもと、）acc, gにしか依存しない。fは再帰回数に関わるが、それは、定数項を足すことで解決できる

Addを解析
f <- acc <- {Add acc g, (\k. k 0)} <- {(\k. k (0 + n))} (帰納的)
g <- g <- {g, (\k. k n)} (固定)
k <- {(\fx. g (\gx. k (fx + gx))), (\n. (n <= 0 => k 0) /\ (n > 0 => k 1))} 再帰が含まれるので無理
fは足し算することがわかる。
複数の整数値が変化するときはタプル（引数を複数にする）

ここまでできるのであれば、高階引数を整数に変形したほうがいい？
高階引数を「使う」場所で返る値が、付属する整数引数と一致することが静的にわかるのであれば、高階引数は除去して整数引数のみにしたほうがいい

簡約回数が定数で、正確に整数に近似できない場合とは？
条件分岐（整数に対する述語）が含まれる場合。（具体的な整数値によって結果が変わるが、具体的な整数値は実際に評価しないとわからない）
その場合は、最大を取る。この場合、式の意味が変わるので、単純に整数に置き換えはできない

** 通常、簡約回数が定数の値であっても、（簡約回数が定数ではない式から）動的に生成される **
例えば、array_sumの配列
すなわち、必ずしも高階の値の具体的な形がわからない。その場合は、その値が「高階の値が持つ整数値」に依存する値を返すとして評価する
（最初だけ値がわからないが、Addとかで再帰で適用されると、再帰ごとの値の変化がわかる）
このときに、具体的な形がわからない式が再帰のたびに入ると、アドホックな近似となるので、避ける？（具体的な形がわかる式に限定してもかなり解けるはず）


k, m = Mult n n
mがkの簡約回数と線形であるとする（これは一般には静的にはわからない）
というかこの時点で、kは任意の定数簡約回数引数に対して定数簡約回数である（静的にはわからないが、そうである）。mがkの情報を表しているので、わかる。
**定数回の簡約とは限らない関数から出てきた値は、関連する整数値の線形で表現できるとは限らない*:
この形は、プログラムをCPS変換した結果で出てくる。というか、整数追加を機械的にやると出てくるが。

しかし、配列の場合はそうではない。
ある程度アドホックに（とくによく使うデータ構造のエンコードには）、返る「高階の値」は引数に依存しないと考える？
再帰のたびに新たに配列を作っている場合は、無理？でも、実用的にあり得る。
定数回数の簡約で配列が更新されているならいいが、そうでない場合は無理。
線形で近似できることを期待するしかない


## 近似のパターン
試したやつはすべて保存すること！！！
* 最小限の整数引数の追加をしたやつ
  * これは、部分適用でも引数を追加しなくて良いのでは？ということ。どこからで結局、その値の情報が流れてくるので. 部分適用状態の高階引数と、そのときにスコープにある変数の情報は必ず一緒に適用される
  * 新たな変数の導入する構文は、bodyにbool型の値しかとらないので、部分適用と新たな変数の導入の間に必ず1つ以上の全適用がある。よって、高階引数とそこでスコープにある全ての変数の情報が必ず一緒に渡される。
  * ∀の中身は、既にeta-展開して、全適用の形になっているからいける
    A (\y. (∀x. M (\k1. k1 x) (\k2. k2 y)))
    A f = ∀z. f z.
    M i j = 
  * 部分適用の部分適用の場合は? 全適用になったタイミングで順次「内側」の部分適用に整数引数が渡っていくから大丈夫なはず
  * しかし、katsura solverで解いた時にunknownになる（型が付かない）場合が増えた (最大不動点があるとunknownになった)
* 機械でできるやつ
* 手でやったやつ
* 使わない引数を削除したやつ
* 機械的に全ての引数の前に追加
* data-flowの解析
* 上記の結果

整数に対して非線形の高階の値の回数だけ再帰するベンチマークを整備
（ただし、最適に整数を追加しても解けないものが多い）



Checkを解析
call-graphを見て、Main, MultのCheckは別とみなしてもいい。
Mult, Check
f <- f <- {(\k. k n), (Pred f)} <- {\k'. k' (n - 1)}
k <- 再帰的な出現
fはkを使わないことがわかる

Main, Check
同様にして、k_iを使わないことがわかる


*/
/* 係数 1, 0 */

%HES
Sentry =u
  ∀n.
    Mult
      [0] (\[k_i] k. k 0) /* {} */
      [n] (\[k_i] k. k n) /* {n} */
      [n] (\[k_i] k. k n) /* {n} */
      [0] (\[g_i] g.
        Main
          [0] (\r. true) /* {} */
          [g_i] g        /* {g_i} */
        
      ) /* {}. 元の式でnは入らないので、（再帰回数にはかかわらないので）近似でも使わない */.

Main [k_i] k [g_i] g =u
  Check
    [g_i] g /* {g_i} */
    [k_i, g_i] (\b.
      (b =  0 => k 0) /\
      (b != 0 =>
        Main
          [k_i] k
          [g_i] (Pred [g_i] g)
      )
    )
    /* {k_i, g_i} */
    .

Mult [acc_i] acc [f_i] f [g_i] g [k_i] k =u
  Check [f_i] f [acc_i, f_i, g_i, k_i] (\b.
    (b = 0 => k [acc_i] acc) /\
    (b = 1 => Mult [acc_i, g_i] (Add acc g) [f_i] (Pred [f_i] f) [g_i] g [k_i] k)
  ).



Add [f_i] f [g_i] g [k_i] k =u f [g_i, k_i] (\fx. g [k_i] (\gx. k (fx + gx))).

Pred [f_i] f [k_i] k =u f [k_i] (\r. k (r - 1)).

Check
  [f_i] f
  [k_i] k =u
    f [k_i] (\n. (n <= 0 => k 0) /\ (n > 0 => k 1)).

/*
validになるとして、考える。それは正しいのか？
validになるために必要な展開回数

Mult j k =u
  (j <= 0 => k 0) /\
  (j > 0 => Mult (j - 1) k).
Multが必要なための条件: j > 0.
/\の部分は、一方がもう一方に影響しない.


Mult j k =u
  (j <= 0 /\ k 0) \/
  (j > 0 /\ Mult (j - 1) k).
これは、jが展開回数であるということを知る必要がある => そこまではできない
*/


/*
/* f : int -> (int -> *) -> *
   k : int -> *
*/
Check f_i f k_i k =u
  f k_i (\n. k 0).

/* ある数までは、、みたいなものはある */

F j k_i k =u
  (k j \/ F (j + 1) k_i k)

Check 0 (F 0) 0 (\n. n = 3)

*/