/* 決定的な分岐 */
/* annotationが無いとtimeout */
/* != 0 を > 0 にするとhoiceで解ける */
%HES
Sentry =v
  ∀m. 
   ∀n. 
    (n <= 0 \/ m <= 0
     \/ (∀r1. 
          ∀r2. 
              r1 < 1 + 1 * n
           \/ r1 < 1 + (-1) * n
           \/ r1 < 1 + 1 * m
           \/ r1 < 1 + (-1) * m
           \/ r1 < 1
           \/ r2 < 1 + 1 * n
           \/ r2 < 1 + (-1) * n
           \/ r2 < 1 + 1 * m
           \/ r2 < 1 + (-1) * m
           \/ r2 < 1
           \/ ACK r1 r2 m n (\x. true)
        )
    )
    /\ (n > 0 /\ m > 0 \/ true).

ACK r1 r2 m n k_ack =v
  r1 > 0 /\ r2 > 0
  /\ (m != 0 \/ k_ack (n + 1))
     /\ (m = 0
         \/ (n != 0
             \/ (∀r1_n. 
                  ∀r2_n. 
                   /*
                   ((r1 >  1 /\ (r1' >= r1 - 1 /\ r2' >= r2)) \/
                    (r1 <= 1 /\ (r1' >= bounds /\ r2' >= r2 - 1))) => 
                   */
                   
                   
                   (r1 <= 1 \/ r1_n < r1 - 1
                    \/ r2_n < r2)
                   /\ (r1 > 1
                       \/ r1_n < 1 + 1 * 1
                       \/ r1_n < 1 + (-1) * 1
                       \/ r1_n < 1 + 1 * (m - 1)
                       \/ r1_n < 1 + (-1) * (m - 1)
                       \/ r1_n < 1
                       \/ r2_n < r2 - 1)
                   \/ ACK r1_n r2_n (m - 1) 1 k_ack))
            /\ (n = 0
                \/ (∀r1_n. 
                     ∀r2_n. 
                      (r1 <= 1 \/ r1_n < r1 - 1
                       \/ r2_n < r2)
                      /\ (r1 > 1
                          \/ r1_n < 1 + 1 * (n - 1)
                          \/ r1_n < 1 + (-1) * (n - 1)
                          \/ r1_n < 1 + 1 * m
                          \/ r1_n < 1 + (-1) * m
                          \/ r1_n < 1 + 1 * (m - 1)
                          \/ r1_n < 1 + (-1) * (m - 1)
                          \/ r1_n < 1
                          \/ r2_n < r2 - 1)
                      \/ ACK r1_n r2_n m (n - 1)
                          (\x. 
                            ∀r1_nn. 
                             ∀r2_nn. 
                              (r1 <= 1 \/ r1_nn < r1 - 1
                               \/ r2_nn < r2)
                              /\ (r1 > 1
                                  \/ r1_nn < 1 + 1 * x
                                  \/ r1_nn < 1 + (-1) * x
                                  \/ r1_nn < 1 + 1 * (m - 1)
                                  \/ r1_nn < 1 + (-1) * (m - 1)
                                  \/ r1_nn < 1
                                  \/ r2_nn < r2 - 1)
                              \/ ACK r1_nn r2_nn (m - 1) x k_ack)))).


%ENV
ACK : r1:int ->
    r2:int ->
    m:int ->
    n:int ->
    k_ack:(t:int -> bool[n < t]) ->
    bool[
        r1 >= 1 /\ r2 >= 1 /\
        n  >= 0 /\ m  >= 0 /\
        (r2 >= 2 + m \/ (r1 >= 1 + n /\ r2 = 1 + m))
    ].

/*
/* 非決定的な場合 */
%ENV
ACK : r1:int ->
    r2:int ->
    m:int ->
    n:int ->
    k_ack:(t:int -> bool[n < t]) ->
    bool[
      r1 >= 1 /\ r2 >= 1 /\
      n  >= 0 /\ m  >= 0 /\
      r1 >= 1 + n /\ r2 >= 1 + m
    ].
*/

/*
; sat
(assert 
  (forall
    ((r1 Int) (r2 Int) (m Int) (n Int))
    (=>
      (and (>= r1 1) (>= r2 1) (>= n 0) (>= m 0) (and (>= r2 (+ 1 m)) (>= r1 (+ 1 n))))
      (and (>= r1 1) (>= r2 1) (>= n 0) (>= m 0) (or  (>= r2 (+ 2 m)) (and (>= r1 (+ 1 n)) (= r2 (+ 1 m)))))
    )
  )
)
(check-sat)
*/