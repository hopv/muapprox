/* should be valid */
%PROGRAM
let g k = if * then (event a; k) else (event b; k)
let f x = if x > 0 then g (f (x - 1)) else (event b; f 5)
let () = f 5

/* %ENV
g : ((qa, 0) /\ (qb, 1) -> qa, 0)
g : ((qa, 0) /\ (qb, 1) -> qb, 0)
f : (int -> qa, 0)
f : (int -> qb, 1)
*/

/* A_{ab} = \complement{(a*b)^{\omega}} = (a*b)*a^{\omega} */
%TRANSITION
qa a -> qa
qa b -> qb

qb a -> qa
qb b -> qb

%PRIORITY
qa -> 0
qb -> 1

/*
HES in example
let main () = f_int_ar_qa__0 5.
g_qa__0_and_qb__1_ar_qa__0 k_qa__0 k_qb__1 = (event a; k_qa__0) /\ (event b; k_qb__1).
g_qa__0_and_qb__1_ar_qb__0 k_qa__0 k_qb__1 = (event a; k_qa__0) /\ (event b; k_qb__1).
f_int_ar_qa__0 x =
  if x > 0 then (
    g_qa__0_and_qb__1_ar_qa__0 (f_int_ar_qa__0 (x-1)) (f_int_ar_qb__1 (x-1))
  ) else (
    event b; f_int_ar_qb__1 5
  ).
f_int_ar_qb__1 x =
  if x > 0 then (
    g_qa__0_and_qb__1_ar_qb__0 (f_int_ar_qa__0 (x-1)) (f_int_ar_qb__1 (x-1))
  ) else (
    event b; f_int_ar_qb__1 5
  ).
  
/*
f_int_ar_qb__1 -> 2
f_int_ar_qa__0 -> 1
g_qa__0_and_qb__1_ar_qa__0 -> 1
g_qa__0_and_qb__1_ar_qb__0 -> 1
*/

%HES
S =v F_int_ar_qa__0 5.

F_int_ar_qb__1 x =v
  (x > 0  => (
    G_qa__0_and_qb__1_ar_qb__0 (F_int_ar_qa__0 (x-1)) (F_int_ar_qb__1 (x-1))
  )) /\ 
  (x <= 0 => F_int_ar_qb__1 5).

F_int_ar_qa__0 x =u
  (x > 0 => (
    G_qa__0_and_qb__1_ar_qa__0 (F_int_ar_qa__0 (x-1)) (F_int_ar_qb__1 (x-1))
  )) /\
  (x <= 0 => F_int_ar_qb__1 5).

G_qa__0_and_qb__1_ar_qa__0 k_qa__0 k_qb__1 =u k_qa__0 /\ k_qb__1.

G_qa__0_and_qb__1_ar_qb__0 k_qa__0 k_qb__1 =u k_qa__0 /\ k_qb__1.
*/

/*
## プログラムの性質
bは、必ず無限回現れる
aは、無限回現れることも現れないこともある

## オートマトンが表す言語の性質
L = 「bが有限回のみ現れる」言語

## よって
Trace /\ L = emptyset
=> 結果のHFLはvalid
*/
